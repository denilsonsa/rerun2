#!/usr/bin/env bash

# USAGE:
#
#   rerun COMMAND
#
# Reruns COMMAND on every filesystem 'modify' event in the current directory.
# Useful for things like running tests whenever you hit 'save' in your editor.
#
# COMMAND is evaluated by Bash before it gets passed to rerun. To prevent
# this you must quote or escape things.
#
# Rerun does not implicitly re-evaluate the command on every iteration,
# it just executes it.
#
# Hence, if a command consists of more than "EXE arg1 arg2 ...", i.e. you
# need Bash to evaluate the command before executing it, e.g. it is a compound
# command featuring ';' or '&&' or '|', then you need to explicitly execute
# your command in a subshell, that will do this evaluation.
# For example, if you would like 'rerun' to execute the COMMAND:
#
#   date ; echo hello
#
# you cannot pass this to 'rerun' directly, because the command needs a shell
# to interpret it on every execution, to take care of the '|', invoking
# separate processes and piping them together. Hence you must:
#
#   rerun sh -c "date ; echo hello"
#
# If COMMAND contains shell aliases, source rerun using a preceding dot:
#
#   . rerun COMMAND
#
# Test cases:
#
#   rerun ls "some file"
#   Used to fail before removing 'eval'.
#
#   rerun ls some*
#   Used to fail due to spaces in matching filenames,
#   before putting quotes on "$@".
#
#   rerun date
#   Updates the displayed date on every iteration.
#
# TODO: I can't get shell aliases to work. :-( e.g:
#   $ rerun ll
#   ll: Command not found
#   $ . rerun ll
#   ll: Command not found
#
# TODO: Can user specify file/directory regexes to be ignored?

# Events that occur within this time from an initial one are ignored
IGNORE_SECS=0.15
IGNORE_NANOSECS="$(echo "$IGNORE_SECS" * 1000000000 | bc)"

function execute() {
    clear
    echo "$@"
    "$@"
}

execute "$@"
ignore_until=$(date +%s%N)

inotifywait --quiet --recursive --monitor --format "%e %w%f" \
    --event modify --event move --event create --event delete \
    --exclude '^\./\.git/' . | while read changed
do

    echo "$changed"

    now_nanosecs="$(date +%s%N)"
    if (( now_nanosecs > ignore_until )) ; then
        let ignore_until=now_nanosecs+IGNORE_NANOSECS
        ( sleep $IGNORE_SECS ; execute "$@" ) &
    fi

done

